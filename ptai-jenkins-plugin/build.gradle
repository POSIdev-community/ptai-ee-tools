plugins {
    // https://github.com/jenkinsci/gradle-jpi-plugin
    id 'org.jenkins-ci.jpi'
}

group = "${rootGroup}"
description = 'This plugin used to implement AST using PT Application Inspector'
version = "${version}"

def pluginName = 'ptai-jenkins-plugin'

repositories {
    maven { url jenkinsPublicRepoUrl }
    maven { url jenkinsIncrementalRepoUrl }
}

jenkinsPlugin {
    // version of Jenkins core this plugin depends on, must be 1.420 or later
    jenkinsVersion = findProperty('jenkinsVersion')

    // ID of the plugin, defaults to the project name without trailing '-plugin'
    shortName = pluginName

    // human-readable name of plugin
    displayName = 'PT Application Inspector Plugin'

    // URL for plugin on Jenkins wiki or elsewhere
    url = 'https://www.ptsecurity.com/ww-en/products/ai/'

    // plugin URL on GitHub, optional
    gitHubUrl = 'https://github.com/POSIdev-community/ptai-ee-tools.git'

    // use the plugin class loader before the core class loader, defaults to false
    // pluginFirstClassLoader = true

    // optional list of package prefixes that your plugin doesn't want to see from core
    // maskClasses = 'groovy.grape org.apache.commons.codec'

    // optional version number from which this plugin release is configuration-compatible
    // compatibleSinceVersion = '1.1.0'

    // set the directory from which the development server will run, defaults to 'work'
    // workDir = file('/tmp/jenkins')

    // URL used to deploy the plugin, defaults to the value shown
    // the system property 'jpi.repoUrl' can be used to override this option
    // repoUrl = 'https://repo.jenkins-ci.org/releases'

    // URL used to deploy snapshots of the plugin, defaults to the value shown
    // the system property 'jpi.snapshotRepoUrl' can be used to override this option
    // snapshotRepoUrl = 'https://repo.jenkins-ci.org/snapshots'

    // enable injection of additional tests for checking the syntax of Jelly and other things
    // disabledTestInjection = false

    // the output directory for the localizer task relative to the project root, defaults to the value shown
    // localizerOutputDir = "${project.buildDir}/generated-src/localizer"

    // disable configuration of Maven Central, the local Maven cache and the Jenkins Maven repository, defaults to true
    configureRepositories = false

    // skip configuration of publications and repositories for the Maven Publishing plugin, defaults to true
    configurePublishing = false

    // plugin file extension, either 'jpi' or 'hpi', defaults to 'hpi'
    fileExtension = 'hpi'

    // the developers section is optional, and corresponds to the POM developers section
    developers {
        developer {
            id 'ZhukovAN'
            name 'Alexey Zhukov'
            email 'alexey.n.zhukov@gmail.com'
        }
    }

    // the licenses section is optional, and corresponds to the POM licenses section
    licenses {
        license {
            name 'Apache License, Version 2.0'
            url 'https://www.apache.org/licenses/LICENSE-2.0.txt'
            distribution 'repo'
            comments 'A business-friendly OSS license'
        }
    }
}

configurations {
    webjars
}

// Retuns -1 if version a is before b, 0 if those are equal and 1 if a is after b
def compareVersion(a, b) {
    List versionA = a.tokenize('.')
    List versionB = b.tokenize('.')

    def commonIndices = Math.min(versionA.size(), versionB.size())
    for (int i = 0; i < commonIndices; ++i) {
        def numberA = versionA[i].toInteger()
        def numberB = versionB[i].toInteger()
        if (numberA != numberB)
            return numberA <=> numberB
    }
    // If we got this far then all the common indices are identical, so whichever version is longer must be more recent
    return versionA.size() <=> versionB.size()
}

dependencies {
    api project(':generic-client-lib')
    api project(':ptai-report-tools')

    String versionString = findProperty('jenkinsVersion')
    // For Jenkins versions [2.413 - 2.427] need to explicitly define some dependencies
    if (1 != compareVersion('2.413', versionString) && -1 != compareVersion('2.427', versionString)) {
        implementation 'com.google.j2objc:j2objc-annotations:2.8'
        implementation 'org.checkerframework:checker-qual:3.38.0'
        annotationProcessor 'org.checkerframework:checker-qual:3.38.0'
    }
    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins/token-macro
    implementation "org.jenkins-ci.plugins:token-macro:${jenkinsTokenMacroPluginVersion}"
    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins/credentials
    implementation "org.jenkins-ci.plugins:credentials:${jenkinsCredentialsPluginVersion}"
    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins/structs
    implementation "org.jenkins-ci.plugins:structs:${jenkinsStructsPluginVersion}"

    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3
    implementation 'org.apache.commons:commons-lang3:3.12.0'
    // https://mvnrepository.com/artifact/org.jooq/joor-java-8
    implementation 'org.jooq:joor-java-8:0.9.13'
    // https://mvnrepository.com/artifact/org.apache.commons/commons-compress
    implementation 'org.apache.commons:commons-compress:1.21'
    // Need this to work with 7zip compression
    // https://mvnrepository.com/artifact/org.tukaani/xz
    implementation 'org.tukaani:xz:1.9'

    // https://mvnrepository.com/artifact/org.webjars/echarts
    webjars 'org.webjars:echarts:5.0.2'

    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins.workflow/workflow-aggregator
    jenkinsServer 'org.jenkins-ci.plugins.workflow:workflow-aggregator:2.7'
    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins/pipeline-utility-steps
    jenkinsServer 'org.jenkins-ci.plugins:pipeline-utility-steps:2.15.0'
    // https://mvnrepository.com/artifact/org.jenkins-ci.plugins/git
    jenkinsServer "org.jenkins-ci.plugins:git:4.11.5"
    // Uncomment this to look how DC trend charts are look like
    // jenkinsServer "org.jenkins-ci.plugins:dependency-check-jenkins-plugin:5.1.1"

    testImplementation(testFixtures(project(':generic-client-lib')))
    testImplementation(testFixtures(project(":ptai-data-structures")))
    testImplementation(testFixtures(project(":ptai-rest-api")))
    testImplementation(testFixtures(project(":generic-client-lib")))

    // Need this to execute Jenkins plugin integration tests
    // https://mvnrepository.com/artifact/org.jenkins-ci.main/jenkins-test-harness
    testImplementation 'org.jenkins-ci.main:jenkins-test-harness:2110.v71145c2d8157'
    // https://mvnrepository.com/artifact/org.jenkins-ci.main/jenkins-war
    testImplementation "org.jenkins-ci.main:jenkins-war:${jenkinsVersion}"
}

// Set Jenkins server debug port
tasks.named('server').configure {
    execSpec {
        debugOptions {
            port.set(8000)
            suspend.set(false)
        }
    }
}

def unpackWebJars = tasks.register('unpack-webjars') {
    doLast {
        // Iterate through JARs from "webjars" configuration
        configurations.webjars.each {jar ->
            def config = configurations.webjars.resolvedConfiguration
            def artifact = config.resolvedArtifacts.find {
                it.file.toString() == jar.absolutePath
            }

            def upStreamVersion = "${artifact.moduleVersion.id.version}"
            upStreamVersion = upStreamVersion.replaceAll(/(-[\d.-]+)/, '')

            def innerJar = "${buildDir}/webjars-content/${artifact.name}"
            logger.quiet("Extracting webjar contents from ${innerJar}")

            copy {
                from zipTree(jar)
                into file("${innerJar}")
            }

            // As webjar contents is a 3rd party code, it's better to avoid putting it
            // to sources / resources folders as files in those folders are pushed to repository.
            // So the best way would be to copy webjar contents to something
            // like $buildDir/generated-resources/webapp and setup JPI task as:
            // tasks.getByName('jpi') {
            //    dependsOn unpackWebJars
            //    from "$buildDir/generated-resources/webapp"
            // }
            // This approach allows us to create HPI file that contains both custom code
            // from src/main/webapp directory and webjars from generated-resources. But
            // Gradle JPI plugin 'server' task generates HPL file that points strictly
            // to webapp folder so Jenkins server started in debug mode using 'gradlew server'
            // command can see only the files from webapp and lacks ones from other folders
            // like generated-sources. So the only solution here is to unpack webjar
            // contents (i.e. JS, CSS, etc.) to webapp/webjars folder and add that folder to .github.
            copy {
                from "${innerJar}/META-INF/resources/webjars/${artifact.name}/${upStreamVersion}",
                        "${innerJar}/META-INF/resources/webjars/${artifact.name}/${artifact.moduleVersion.id.version}"

                into "src/main/webapp/webjars/${artifact.name}"
            }
        }
    }
}

tasks.getByName('jpi') {
    dependsOn unpackWebJars
}

clean {
    delete 'src/main/webapp/webjars'
}

tasks.register('deleteJar', Delete) {
    delete file("build/libs/${pluginName}-${version}.jar")
}

tasks.named('build') {
    finalizedBy 'deleteJar'
}

jar {
    // See https://www.jenkins.io/blog/2018/01/13/jep-200/
    manifest {
        attributes 'Jenkins-ClassFilter-Whitelisted': 'true'
    }
}
